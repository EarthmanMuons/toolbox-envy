#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat >&2 <<'USAGE'
Usage:
  bump-semver (--major | --minor | --patch | --set <x.y.z>)
             [--prerelease <id>] [--build <meta>]
             [<version>]

Bump or set a SemVer version. Reads version from stdin or arg.

Options:
  --major | --minor | --patch  Increment core version
  --set <x.y.z>                Set core version
  --prerelease <id>            Append prerelease (e.g. rc.1)
  --build <meta>               Append build metadata
  -h, --help                   Show this help message
USAGE
}

die() {
	printf "ERROR: %s\n" "$*" >&2
	exit 1
}

validate_prerelease() {
	local pr="$1"
	IFS='.' read -r -a parts <<<"$pr"
	for part in "${parts[@]}"; do
		[[ -n $part ]] || return 1
		[[ $part =~ ^[0-9A-Za-z-]+$ ]] || return 1
		if [[ $part =~ ^[0-9]+$ ]] && [[ $part =~ ^0[0-9]+$ ]]; then
			return 1
		fi
	done
	return 0
}

validate_build() {
	local b="$1"
	IFS='.' read -r -a parts <<<"$b"
	for part in "${parts[@]}"; do
		[[ -n $part ]] || return 1
		[[ $part =~ ^[0-9A-Za-z-]+$ ]] || return 1
	done
	return 0
}

# Defaults (populated/overridden by parse_args)
op=""
set_core=""
want_prerelease="false"
want_build="false"
prerelease_val=""
build_val=""

parse_args() {
	positional=()

	while [[ $# -gt 0 ]]; do
		case "$1" in
		-h | --help)
			usage
			exit 0
			;;
		--major | --minor | --patch)
			[[ -z $op ]] || die "Only one of --major/--minor/--patch/--set may be specified"
			op="${1#--}"
			shift
			;;
		--set)
			[[ -z $op ]] || die "Only one of --major/--minor/--patch/--set may be specified"
			op="set"
			shift
			[[ $# -gt 0 ]] || die "--set requires an argument X.Y.Z"
			set_core="$1"
			shift
			;;
		--prerelease)
			want_prerelease="true"
			shift
			[[ $# -gt 0 ]] || die "--prerelease requires an argument"
			prerelease_val="$1"
			shift
			;;
		--build)
			want_build="true"
			shift
			[[ $# -gt 0 ]] || die "--build requires an argument"
			build_val="$1"
			shift
			;;
		--*) die "Unknown option: $1" ;;
		*)
			positional+=("$1")
			shift
			;;
		esac
	done
}

validate_inputs() {
	[[ -n $op ]] || {
		usage
		die "One of --major/--minor/--patch/--set is required"
	}
	[[ ${#positional[@]} -le 1 ]] || die "At most one VERSION argument may be provided"
}

read_input_version() {
	local stdin_has_data="false"
	local stdin_content=""

	if [[ ! -t 0 ]]; then
		stdin_content="$(cat || true)"
		if [[ -n ${stdin_content//$'\n'/} ]]; then
			stdin_has_data="true"
		fi
	fi

	if [[ ${#positional[@]} -eq 1 && $stdin_has_data == "true" ]]; then
		die "Provide version via stdin OR positional argument, not both"
	fi
	if [[ ${#positional[@]} -eq 0 && $stdin_has_data == "false" ]]; then
		usage
		die "No version provided (expected stdin or positional VERSION)"
	fi

	if [[ ${#positional[@]} -eq 1 ]]; then
		printf '%s' "${positional[0]}"
	else
		printf '%s' "$stdin_content" | awk 'NF { print $0; exit }'
	fi
}

main() {
	parse_args "$@"
	validate_inputs

	local input_version=""
	input_version="$(read_input_version)"
	input_version="$(printf '%s' "$input_version" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
	[[ -n $input_version ]] || die "Empty version input"

	input_version="${input_version#v}"
	input_version="${input_version#V}"

	local semver_re='^([0-9]+)\.([0-9]+)\.([0-9]+)(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$'
	[[ $input_version =~ $semver_re ]] || die "Invalid SemVer input: '$input_version'"

	local maj="${BASH_REMATCH[1]}"
	local min="${BASH_REMATCH[2]}"
	local pat="${BASH_REMATCH[3]}"

	for n in "$maj" "$min" "$pat"; do
		[[ $n =~ ^0[0-9]+$ ]] && die "Invalid SemVer core number with leading zero: '$n' in '$input_version'"
	done

	if [[ $want_prerelease == "true" && -n $prerelease_val ]]; then
		validate_prerelease "$prerelease_val" || die "Invalid --prerelease value: '$prerelease_val'"
	fi
	if [[ $want_build == "true" && -n $build_val ]]; then
		validate_build "$build_val" || die "Invalid --build value: '$build_val'"
	fi

	local new_major="$maj"
	local new_minor="$min"
	local new_patch="$pat"

	case "$op" in
	major)
		new_major=$((maj + 1))
		new_minor=0
		new_patch=0
		;;
	minor)
		new_minor=$((min + 1))
		new_patch=0
		;;
	patch) new_patch=$((pat + 1)) ;;
	set)
		[[ $set_core =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]] || die "--set must be exactly X.Y.Z"
		new_major="${BASH_REMATCH[1]}"
		new_minor="${BASH_REMATCH[2]}"
		new_patch="${BASH_REMATCH[3]}"
		for n in "$new_major" "$new_minor" "$new_patch"; do
			[[ $n =~ ^0[0-9]+$ ]] && die "--set contains a core number with leading zero: '$set_core'"
		done
		;;
	*) die "Internal error: unknown op '$op'" ;;
	esac

	local out="${new_major}.${new_minor}.${new_patch}"
	if [[ $want_prerelease == "true" && -n $prerelease_val ]]; then
		out="${out}-${prerelease_val}"
	fi
	if [[ $want_build == "true" && -n $build_val ]]; then
		out="${out}+${build_val}"
	fi

	printf '%s\n' "$out"
}

main "$@"
