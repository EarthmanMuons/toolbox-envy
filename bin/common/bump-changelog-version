#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat >&2 <<'USAGE'
Usage:
  bump-changelog-version <new-semver>
  get-project-version | bump-changelog-version

Update CHANGELOG.md (Keep a Changelog style):
- Move "## [Unreleased]" to
  "## [<new>] - <today>"
- Insert a fresh "## [Unreleased]" above it
- Update reference links for [Unreleased] and [<new>]

Options:
  -h, --help  Show this help message
USAGE
}

die() {
	printf "ERROR: %s\n" "$*" >&2
	exit 1
}

is_semver() {
	local s="$1"
	local num_id='(0|[1-9][0-9]*)'
	local pre_id="(${num_id}|[0-9A-Za-z-]*[A-Za-z-][0-9A-Za-z-]*)"
	local pre="(-${pre_id}(\\.${pre_id})*)?"
	local build_id='[0-9A-Za-z-]+'
	local build="(\\+${build_id}(\\.${build_id})*)?"
	local core="${num_id}\\.${num_id}\\.${num_id}"
	local semver="^${core}${pre}${build}$"
	[[ $s =~ $semver ]]
}

read_version_from_stdin() {
	local data lines count
	data="$(cat || true)"
	data="$(printf '%s' "$data" | tr -d '\r')"

	lines="$(
		printf '%s\n' "$data" |
			awk '
        {
          line=$0
          sub(/^[[:space:]]+/, "", line)
          sub(/[[:space:]]+$/, "", line)
          if (line != "") print line
        }
      '
	)"

	[[ -n $lines ]] || die "No version provided on stdin."

	count="$(printf '%s\n' "$lines" | awk 'END { print NR }')"
	[[ $count -eq 1 ]] || die "Expected exactly one non-empty line on stdin (got $count)."

	printf '%s\n' "$lines"
}

resolve_repo_root() {
	local root=""

	if [[ -n ${GITHUB_WORKSPACE-} ]]; then
		root="$GITHUB_WORKSPACE"
	elif command -v git >/dev/null 2>&1; then
		root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
	fi

	if [[ -n $root ]]; then
		root="$(cd "$root" && pwd -P)"
	fi

	if [[ -z $root ]]; then
		die "Could not determine repository's top-level directory."
	fi

	printf '%s' "$root"
}

# Defaults (populated/overridden by parse_args)
new_version=""

parse_args() {
	case "${1:-}" in
	"") ;;
	-h | --help)
		usage
		exit 0
		;;
	*) ;;
	esac

	if [[ $# -eq 1 ]]; then
		new_version="$1"
	elif [[ $# -eq 0 ]]; then
		if [[ -t 0 ]]; then
			usage
			exit 1
		fi
		new_version="$(read_version_from_stdin)"
	else
		usage
		exit 1
	fi
}

find_prev_version() {
	local changelog="$1"
	awk '
    BEGIN { in_unrel=0; }
    /^##[[:space:]]+\[Unreleased\][[:space:]]*$/ { in_unrel=1; next; }

    in_unrel && /^##[[:space:]]+\[/ {
      line=$0
      sub(/^##[[:space:]]+\[/, "", line)
      sub(/\].*$/, "", line)
      # Accept semver-like tokens only (allow prerelease/build-ish separators)
      if (line ~ /^[0-9]+\.[0-9]+\.[0-9]+([+-][0-9A-Za-z.-]+)*$/) {
        print line
        exit 0
      }
    }
  ' "$changelog"
}

detect_tag_prefix() {
	local changelog="$1"
	awk '
    function inspect_url(url) {
      # v-prefixed compare/commits
      if (url ~ /\/compare\/v[0-9]+\.[0-9]+\.[0-9]+([+-][0-9A-Za-z.-]+)*\.\.\./) { print "v"; exit 0 }
      if (url ~ /\/commits\/v[0-9]+\.[0-9]+\.[0-9]+([+-][0-9A-Za-z.-]+)*$/)     { print "v"; exit 0 }

      # Record that we saw unprefixed forms (not used to output anything today)
      if (url ~ /\/compare\/[0-9]+\.[0-9]+\.[0-9]+([+-][0-9A-Za-z.-]+)*\.\.\./) { saw_unpref=1 }
      if (url ~ /\/commits\/[0-9]+\.[0-9]+\.[0-9]+([+-][0-9A-Za-z.-]+)*$/)      { saw_unpref=1 }
    }

    BEGIN { expect_url=0 }

    /^\[[^]]+\]:/ {
      expect_url = 0

      # If URL is on the same line, inspect it.
      if ($0 ~ /^\[[^]]+\]:[[:space:]]+https?:\/\//) {
        inspect_url($2)
        next
      }

      # Otherwise, expect a continuation URL on the next non-empty line.
      expect_url = 1
      next
    }

    expect_url {
      if ($0 ~ /^[[:space:]]*$/) next
      url=$0
      gsub(/^[[:space:]]+/, "", url)
      gsub(/[[:space:]]+$/, "", url)
      if (url ~ /^https?:\/\//) inspect_url(url)
      expect_url = 0
    }

    END { print "" }
  ' "$changelog"
}

read_unreleased_url() {
	local changelog="$1"
	awk '
    /^\[Unreleased\]:/ {
      # Match the definition line. It might be:
      #   [Unreleased]: https://...
      # or (wrapped):
      #   [Unreleased]:
      #     https://...
      if ($0 ~ /^\[Unreleased\]:[[:space:]]+https?:\/\//) {
        print $2
        exit 0
      }

      # Otherwise, read forward to find the next non-empty line and treat it as the URL.
      while ((getline nextline) > 0) {
        if (nextline ~ /^[[:space:]]*$/) continue

        gsub(/^[[:space:]]+/, "", nextline)
        gsub(/[[:space:]]+$/, "", nextline)

        # Accept only http(s) URLs as the continuation.
        if (nextline ~ /^https?:\/\//) {
          print nextline
          exit 0
        }

        # If the very next non-empty line is not a URL, bail.
        exit 1
      }
      exit 1
    }
  ' "$changelog" || true
}

rewrite_changelog() {
	local changelog="$1"
	local new_version="$2"
	local today="$3"
	local new_unrel_link="$4"
	local new_ver_link="$5"

	local tmp=""
	tmp="$(mktemp "${TMPDIR:-/tmp}/changelog.XXXXXX")"
	trap 'rm -f "'"$tmp"'"' EXIT

	awk -v newv="$new_version" \
		-v today="$today" \
		-v new_unrel_link="$new_unrel_link" \
		-v new_ver_link="$new_ver_link" '
  BEGIN {
    did_rewrite_headings = 0;
    did_unreleased_link = 0;
    skip_next_unreleased_url = 0;
  }

  skip_next_unreleased_url {
    if ($0 ~ /^[[:space:]]+https?:\/\//) { skip_next_unreleased_url = 0; next }
    skip_next_unreleased_url = 0
  }

  /^##[[:space:]]+\[Unreleased\][[:space:]]*$/ && !did_rewrite_headings {
    print "## [Unreleased]";
    print "";
    print "## [" newv "] - " today;
    did_rewrite_headings = 1;
    next;
  }

  /^\[Unreleased\]:/ && !did_unreleased_link {
    print "[Unreleased]: " new_unrel_link;
    print "[" newv "]: " new_ver_link;
    did_unreleased_link = 1;

    if ($0 !~ /^\[Unreleased\]:[[:space:]]+https?:\/\//) {
      skip_next_unreleased_url = 1
    }
    next;
  }

  { print }

  END {
    if (!did_rewrite_headings) {
      print "ERROR: did not find ## [Unreleased] heading" > "/dev/stderr";
      exit 3;
    }
    if (!did_unreleased_link) {
      print "ERROR: did not find [Unreleased]: reference link" > "/dev/stderr";
      exit 3;
    }
  }
' "$changelog" >"$tmp"

	cp "$tmp" "$changelog"
	rm -f "$tmp"
	trap - EXIT
}

main() {
	parse_args "$@"

	is_semver "$new_version" || die "Invalid semver: '$new_version'"

	local repo_root=""
	repo_root="$(resolve_repo_root)"

	local changelog="$repo_root/CHANGELOG.md"
	[[ -f $changelog ]] || die "Missing file: $changelog"

	local today=""
	today="$(date +%F)"

	local prev_version=""
	prev_version="$(find_prev_version "$changelog")"
	[[ -n $prev_version ]] || die "Could not find the next ## [<version>] heading after ## [Unreleased]."

	if grep -Eq "^##[[:space:]]+\[$new_version\]" "$changelog"; then
		die "Version '$new_version' already appears as a ## heading in CHANGELOG.md."
	fi

	local tag_prefix=""
	tag_prefix="$(detect_tag_prefix "$changelog")"

	local unreleased_url=""
	unreleased_url="$(read_unreleased_url "$changelog")"
	[[ -n $unreleased_url ]] || die "Could not find a reference link for [Unreleased]"

	local repo_base=""
	repo_base="$(printf '%s\n' "$unreleased_url" | sed -E 's#^(https?://[^/]+/[^/]+/[^/]+).*$#\1#')"
	[[ -n $repo_base ]] || die "Could not derive repo base URL from: $unreleased_url"

	local new_unreleased_link="${repo_base}/compare/${tag_prefix}${new_version}...HEAD"
	local new_version_link="${repo_base}/compare/${tag_prefix}${prev_version}...${tag_prefix}${new_version}"

	rewrite_changelog "$changelog" "$new_version" "$today" "$new_unreleased_link" "$new_version_link"

	printf "Updated %s: Unreleased -> %s (%s); links: %s -> %s\n" \
		"$changelog" "$new_version" "$today" "$prev_version" "$new_version"
}

main "$@"
