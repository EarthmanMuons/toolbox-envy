#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat >&2 <<'USAGE'
Usage:
  verify-checksums [--dir <dir>] [--pattern <glob> ...]

Verify asset SHA-256 checksums against sha256sums.txt.

Options:
  -d, --dir <dir>       Directory containing the assets (default: dist)
  -p, --pattern <glob>  Only verify files matching <glob> (default: *)
                        May be specified multiple times.
  -h, --help            Show this help message.
USAGE
}

die() {
	printf "ERROR: %s\n" "$*" >&2
	exit 1
}

# Defaults (populated/overridden by parse_args)
dist_dir="dist"
patterns=()
checksums_file="sha256sums.txt"

parse_args() {
	while (($#)); do
		case "$1" in
		-d | --dir)
			shift
			dist_dir="${1-}"
			[[ -n $dist_dir ]] || die "--dir requires a value"
			;;
		-p | --pattern)
			shift
			pattern="${1-}"
			[[ -n $pattern ]] || die "--pattern requires a value"
			patterns+=("$pattern")
			;;
		-h | --help)
			usage
			exit 0
			;;
		*) die "Unknown argument: $1" ;;
		esac
		shift
	done
}

validate_inputs() {
	if ((${#patterns[@]} == 0)); then
		patterns=("*")
	fi

	[[ -d $dist_dir ]] || die "Dist directory not found: $dist_dir"
	[[ -f "$dist_dir/$checksums_file" ]] || die "$checksums_file not found in $dist_dir"
}

# Outputs:
#   sets global ASSET_PATHS
#   sets global ASSET_FILENAMES
collect_assets() {
	shopt -s nullglob
	local pattern
	for pattern in "${patterns[@]}"; do
		local -a pattern_matches=()
		# shellcheck disable=SC2206 # Intentional: allow glob expansion from user-provided --pattern.
		pattern_matches=("$dist_dir"/$pattern)

		if ((${#pattern_matches[@]} == 0)); then
			die "No files matched pattern: $pattern"
		fi

		local matched_any=0
		local f base
		for f in "${pattern_matches[@]}"; do
			[[ -f $f ]] || continue
			base="${f##*/}"
			[[ $base == "$checksums_file" ]] && continue
			matched_any=1
			add_unique_asset "$f"
		done

		if ((matched_any == 0)); then
			die "No files matched pattern (after excluding $checksums_file): $pattern"
		fi
	done
	shopt -u nullglob

	((${#ASSET_PATHS[@]} > 0)) || die "No assets matched patterns"
}

add_unique_asset() {
	local path="$1"
	local existing

	if ((${#ASSET_PATHS[@]} > 0)); then
		for existing in "${ASSET_PATHS[@]}"; do
			[[ $existing == "$path" ]] && return 0
		done
	fi

	ASSET_PATHS+=("$path")
	ASSET_FILENAMES+=("${path##*/}")
}

# Outputs:
#   sets global CHECKSUM_LINE
lookup_checksum_line() {
	CHECKSUM_LINE=""

	local checksums_path="$dist_dir/$checksums_file"
	local asset_filename="$1"

	local line=""
	local match_count=0

	while IFS= read -r line; do
		# Match the common "HASH  filename" format used by sha256sum,
		# and the binary mode "HASH *filename" format.
		case "$line" in
		*"  $asset_filename" | *" *$asset_filename")
			match_count=$((match_count + 1))
			if ((match_count == 1)); then
				CHECKSUM_LINE="$line"
			else
				# Defer error output until after we've collected enough to know it's multiple.
				:
			fi
			;;
		esac
	done <"$checksums_path"

	if ((match_count == 0)); then
		die "No checksum entry found for $asset_filename in $checksums_file"
	fi

	if ((match_count != 1)); then
		printf "ERROR: Multiple checksum entries found for %s in %s.\n" "$asset_filename" "$checksums_file" >&2
		while IFS= read -r line; do
			case "$line" in
			*"  $asset_filename" | *" *$asset_filename") printf '%s\n' "$line" >&2 ;;
			esac
		done <"$checksums_path"
		exit 1
	fi
}

verify_checksum_line() {
	local line="$1"

	if command -v sha256sum >/dev/null 2>&1; then
		(cd "$dist_dir" && printf '%s\n' "$line" | sha256sum -c -)
	elif command -v shasum >/dev/null 2>&1; then
		(cd "$dist_dir" && printf '%s\n' "$line" | shasum -a 256 -c -)
	else
		die "Need sha256sum or shasum to verify SHA-256 checksums."
	fi
}

main() {
	parse_args "$@"
	validate_inputs

	ASSET_PATHS=()
	ASSET_FILENAMES=()
	collect_assets

	local i asset_filename
	for i in "${!ASSET_PATHS[@]}"; do
		asset_filename="${ASSET_FILENAMES[$i]}"
		lookup_checksum_line "$asset_filename"
		verify_checksum_line "$CHECKSUM_LINE"
	done

}

main "$@"
