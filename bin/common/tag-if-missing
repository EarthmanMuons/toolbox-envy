#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat <<'USAGE'
Usage:
  tag-if-missing [--remote <name>] [--dry-run] [<tag-or-version>]

Create and push a git tag if it does not already exist.
Reads the tag/version from stdin or arg.
If input is SemVer, prefixes "v".

Options:
  --remote <name>  Remote to check/push to (default: origin)
  --dry-run        Do not create or push; report to stderr
  -h, --help       Show this help
USAGE
}

die() {
	echo "ERROR: $*" >&2
	exit 1
}

need_cmd() {
	command -v "$1" >/dev/null 2>&1 || die "Required command not found in PATH: $1"
}

resolve_repo_root() {
	local root=""

	if [[ -n ${GITHUB_WORKSPACE-} ]]; then
		root="$GITHUB_WORKSPACE"
	elif command -v git >/dev/null 2>&1; then
		root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
	fi

	if [[ -n $root ]]; then
		root="$(cd "$root" && pwd -P)"
	fi

	if [[ -z $root ]]; then
		die "Could not determine repository's top-level directory."
	fi

	printf '%s' "$root"
}

is_semver() {
	local s="$1"
	local num_id='(0|[1-9][0-9]*)'
	local pre_id="(${num_id}|[0-9A-Za-z-]*[A-Za-z-][0-9A-Za-z-]*)"
	local pre="(-${pre_id}(\\.${pre_id})*)?"
	local build_id='[0-9A-Za-z-]+'
	local build="(\\+${build_id}(\\.${build_id})*)?"
	local core="${num_id}\\.${num_id}\\.${num_id}"
	local semver="^${core}${pre}${build}$"
	[[ $s =~ $semver ]]
}

local_tag_exists() {
	git show-ref --tags --verify --quiet "refs/tags/$1"
}

remote_tag_exists() {
	local remote="$1"
	local tag="$2"
	git ls-remote --exit-code --tags "$remote" "refs/tags/$tag" >/dev/null 2>&1
}

read_input() {
	local arg="${1:-}"

	if [[ -n $arg ]]; then
		printf '%s' "$arg"
		return 0
	fi

	if [[ ! -t 0 ]]; then
		local line
		IFS= read -r line || true
		line="${line//$'\r'/}"
		line="${line#"${line%%[![:space:]]*}"}"
		line="${line%"${line##*[![:space:]]}"}"
		printf '%s' "$line"
		return 0
	fi

	printf ''
}

# Defaults (populated/overridden by parse_args)
remote="origin"
dry_run="0"

parse_args() {
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--remote)
			[[ $# -ge 2 ]] || die "--remote requires a value"
			remote="$2"
			shift 2
			;;
		--dry-run)
			dry_run="1"
			shift
			;;
		-h | --help)
			usage
			exit 0
			;;
		--)
			shift
			break
			;;
		-*)
			die "unknown option: $1 (try --help)"
			;;
		*)
			break
			;;
		esac
	done

	positional=()
	if [[ $# -gt 0 ]]; then
		positional+=("$1")
	fi
}

main() {
	parse_args "$@"

	need_cmd git

	local repo_root
	repo_root="$(resolve_repo_root)"
	cd "$repo_root"

	git remote get-url "$remote" >/dev/null 2>&1 || die "remote '$remote' does not exist"

	local raw
	raw="$(read_input "${positional[0]:-}")"
	[[ -n $raw ]] || die "no version/tag provided (pass an argument or pipe one via stdin)"

	local tag=""
	if is_semver "$raw"; then
		tag="v$raw"
	elif [[ $raw == v* ]] && is_semver "${raw#v}"; then
		tag="$raw"
	else
		die "input must be SemVer (optionally prefixed with 'v'); got: '$raw'"
	fi

	if local_tag_exists "$tag"; then
		exit 0
	fi

	if remote_tag_exists "$remote" "$tag"; then
		exit 0
	fi

	if [[ $dry_run == "1" ]]; then
		printf 'DRY-RUN: would create and push tag %s (remote: %s)\n' "$tag" "$remote" >&2
		exit 0
	fi

	git tag -a "$tag" -m "Release $tag"
	git push "$remote" "refs/tags/$tag"

	printf '%s\n' "$tag"
}

main "$@"
