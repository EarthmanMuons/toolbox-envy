#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat >&2 <<'USAGE'
Usage:
  bump-calver [--format <format>] [<date>]

Print a CalVer for a date (UTC).
Reads date from stdin or arg; if empty, uses today.

Accepted DATE forms:
  YYYY-MM-DD, YYYY.MM.DD, YYYY/MM/DD, YYYYMMDD

Options:
  --format <format>  Override output format (default: YYYY.MM.DD)
  -h, --help          Show this help message.

Tokens:
  YYYY  Full year            (e.g. 2006, 2016, 2106)
  YY    Short year           (year % 1000, no padding: 6, 16, 106)
  0Y    Zero-padded year     (min 2 digits: 06, 16, 106)
  MM    Short month          (1..12)
  0M    Zero-padded month    (01..12)
  WW    Short week (ISO)     (1..53)
  0W    Zero-padded week     (01..53)
  DD    Short day            (1..31)
  0D    Zero-padded day      (01..31)
USAGE
}

die() {
	printf "ERROR: %s\n" "$*" >&2
	exit 1
}

is_gnu_date() {
	date --version >/dev/null 2>&1
}

# Format a validated YYYY-MM-DD date in UTC using strftime format.
date_utc_fmt_ymd() {
	local ymd="$1"
	local fmt="$2"

	if is_gnu_date; then
		date -u -d "$ymd" +"$fmt"
	else
		date -u -j -f "%Y-%m-%d" "$ymd" +"$fmt"
	fi
}

validate_ymd() {
	local ymd="$1"
	local out=""

	out="$(date_utc_fmt_ymd "$ymd" "%Y-%m-%d")" || return 1
	[[ $out == "$ymd" ]] || return 1
	return 0
}

normalize_input_to_ymd() {
	local raw="$1"
	raw="$(printf '%s' "$raw" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
	[[ -n $raw ]] || die "Empty date input"

	local y="" m="" d=""

	if [[ $raw =~ ^([0-9]{4})[-./]([0-9]{1,2})[-./]([0-9]{1,2})$ ]]; then
		y="${BASH_REMATCH[1]}"
		m="${BASH_REMATCH[2]}"
		d="${BASH_REMATCH[3]}"
	elif [[ $raw =~ ^([0-9]{4})([0-9]{2})([0-9]{2})$ ]]; then
		y="${BASH_REMATCH[1]}"
		m="${BASH_REMATCH[2]}"
		d="${BASH_REMATCH[3]}"
	else
		die "Unsupported date format: '$raw'"
	fi

	[[ $m =~ ^[0-9]+$ && $d =~ ^[0-9]+$ ]] || die "Invalid numeric date: '$raw'"

	# Use arithmetic context for base-10 normalization (avoids octal interpretation)
	local yi mi di
	yi=$((10#$y))
	mi=$((10#$m))
	di=$((10#$d))

	((mi >= 1 && mi <= 12)) || die "Invalid month in date: '$raw'"
	((di >= 1 && di <= 31)) || die "Invalid day in date: '$raw'"

	printf '%04d-%02d-%02d' "$yi" "$mi" "$di"
}

apply_calver_format() {
	local ymd="$1"
	local fmt="$2"

	local Y M D W
	Y="$(date_utc_fmt_ymd "$ymd" "%Y")"
	M="$(date_utc_fmt_ymd "$ymd" "%m")"
	D="$(date_utc_fmt_ymd "$ymd" "%d")"
	W="$(date_utc_fmt_ymd "$ymd" "%V")"

	local tok_YYYY="$Y"

	local year_mod=$((10#$Y % 1000))
	local tok_YY="$year_mod"
	local tok_0Y
	tok_0Y="$(printf '%02d' "$year_mod")"

	local month_int=$((10#$M))
	local day_int=$((10#$D))
	local week_int=$((10#$W))

	local tok_MM="$month_int"
	local tok_0M
	tok_0M="$(printf '%02d' "$month_int")"

	local tok_DD="$day_int"
	local tok_0D
	tok_0D="$(printf '%02d' "$day_int")"

	local tok_WW="$week_int"
	local tok_0W
	tok_0W="$(printf '%02d' "$week_int")"

	local out="$fmt"
	out="${out//YYYY/$tok_YYYY}"
	out="${out//0Y/$tok_0Y}"
	out="${out//YY/$tok_YY}"
	out="${out//0M/$tok_0M}"
	out="${out//MM/$tok_MM}"
	out="${out//0W/$tok_0W}"
	out="${out//WW/$tok_WW}"
	out="${out//0D/$tok_0D}"
	out="${out//DD/$tok_DD}"

	printf '%s\n' "$out"
}

# Defaults (populated/overridden by parse_args)
default_format="YYYY.MM.DD" # broad SemVer compatibility (no zero-padding)
format=""

parse_args() {
	positional=()

	while [[ $# -gt 0 ]]; do
		case "$1" in
		-h | --help)
			usage
			exit 0
			;;
		--format)
			shift
			[[ $# -gt 0 ]] || die "--format requires an argument"
			format="$1"
			shift
			;;
		--*) die "Unknown option: $1" ;;
		*)
			positional+=("$1")
			shift
			;;
		esac
	done
}

validate_inputs() {
	[[ ${#positional[@]} -le 1 ]] || die "At most one DATE argument may be provided"

	format="$(printf '%s' "$format" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
	if [[ -z $format ]]; then
		format="$default_format"
	fi
}

read_input_date() {
	local stdin_has_data="false"
	local stdin_content=""

	if [[ ! -t 0 ]]; then
		stdin_content="$(cat || true)"
		if [[ -n ${stdin_content//$'\n'/} ]] && [[ -n ${stdin_content//[[:space:]]/} ]]; then
			stdin_has_data="true"
		fi
	fi

	if [[ ${#positional[@]} -eq 1 && $stdin_has_data == "true" ]]; then
		die "Provide date via stdin OR positional argument, not both"
	fi

	if [[ ${#positional[@]} -eq 1 ]]; then
		printf '%s' "${positional[0]}"
		return
	fi

	if [[ $stdin_has_data == "true" ]]; then
		printf '%s' "$stdin_content" | awk 'NF { print $0; exit }'
		return
	fi

	printf ''
}

main() {
	parse_args "$@"
	validate_inputs

	local input_date=""
	input_date="$(read_input_date)"

	local ymd=""
	if [[ -z $input_date ]]; then
		ymd="$(date -u +%Y-%m-%d)"
	else
		ymd="$(normalize_input_to_ymd "$input_date")"
		validate_ymd "$ymd" || die "Invalid calendar date: '$input_date' (normalized to '$ymd')"
	fi

	apply_calver_format "$ymd" "$format"
}

main "$@"
