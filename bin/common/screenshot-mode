#!/usr/bin/env bash
set -euo pipefail

usage() {
	cat >&2 <<'USAGE'
Usage:
  screenshot-mode apply --platform <platform>
                 [--device <device> | --serial <serial>] [--dry-run]
  screenshot-mode reset --platform <platform>
                 [--device <device> | --serial <serial>] [--dry-run]

Canonical screenshot mode for iOS Simulator and Android emulators.

Options:
  -p, --platform <platform>  One of: ios, android
  -n, --dry-run              Print the command(s) without running them
  -d, --device <device>      iOS only. simctl device selector
                             (default: booted)
  -s, --serial <serial>      Android only. adb device serial
  -h, --help                 Show this help message
USAGE
}

die() {
	printf "ERROR: %s\n" "$*" >&2
	exit 1
}

need_cmd() {
	command -v "$1" >/dev/null 2>&1 || die "Required command not found in PATH: $1"
}

# iOS status bar
IOS_TIME="9:41"
IOS_WIFI_BARS="3"
IOS_CELLULAR_BARS="4"
IOS_BATTERY_LEVEL="100"
IOS_BATTERY_STATE="discharging"

# Android emulator state
ANDROID_TIME_HHMM="09:41"
ANDROID_DATE_YMD="2026-01-29"
ANDROID_BATTERY_LEVEL="100"
ANDROID_BATTERY_STATUS="3"

android_adb_date() {
	local ymd="$1" hm="$2"
	printf '%s%s%s%s%s' \
		"${ymd:5:2}" \
		"${ymd:8:2}" \
		"${hm:0:2}" \
		"${hm:3:2}" \
		"${ymd:0:4}"
}

# Defaults (populated/overridden by parse_args)
CMD=""
PLATFORM=""
DRY_RUN="0"
IOS_DEVICE="booted"
ANDROID_SERIAL=""

parse_args() {
	if [[ $# -eq 0 ]]; then
		usage
		exit 1
	fi
	if [[ ${1:-} == "-h" || ${1:-} == "--help" ]]; then
		usage
		exit 0
	fi

	CMD="$1"
	shift

	while [[ $# -gt 0 ]]; do
		case "$1" in
		-p | --platform)
			[[ $# -ge 2 ]] || die "--platform requires a value"
			PLATFORM="$2"
			shift 2
			;;
		-n | --dry-run)
			DRY_RUN="1"
			shift
			;;
		-d | --device)
			[[ $# -ge 2 ]] || die "--device requires a value"
			IOS_DEVICE="$2"
			shift 2
			;;
		-s | --serial)
			[[ $# -ge 2 ]] || die "--serial requires a value"
			ANDROID_SERIAL="$2"
			shift 2
			;;
		-h | --help)
			usage
			exit 0
			;;
		--)
			shift
			break
			;;
		-*)
			die "Unknown option: $1"
			;;
		*)
			die "Unexpected argument: $1"
			;;
		esac
	done
}

validate_inputs() {
	[[ -n $PLATFORM ]] || die "--platform is required (ios|android)"

	case "$PLATFORM" in
	ios | android) ;;
	*) die "--platform must be one of: ios, android (got: $PLATFORM)" ;;
	esac

	if [[ $PLATFORM == "ios" && -n $ANDROID_SERIAL ]]; then
		die "--serial is Android-only; use --device for iOS"
	fi
	if [[ $PLATFORM == "android" && $IOS_DEVICE != "booted" ]]; then
		die "--device is iOS-only; use --serial for Android"
	fi
}

ios_run() {
	local -a cmd=(xcrun simctl status_bar "$IOS_DEVICE")
	cmd+=("$@")

	if [[ $DRY_RUN == "1" ]]; then
		printf '%q ' "${cmd[@]}"
		printf '\n'
	else
		"${cmd[@]}"
	fi
}

ios_apply() {
	[[ $DRY_RUN == "1" ]] || need_cmd xcrun
	ios_run override \
		--time "$IOS_TIME" \
		--wifiBars "$IOS_WIFI_BARS" \
		--cellularBars "$IOS_CELLULAR_BARS" \
		--batteryLevel "$IOS_BATTERY_LEVEL" \
		--batteryState "$IOS_BATTERY_STATE"
	[[ $DRY_RUN == "1" ]] || echo "Applied iOS screenshot mode to simulator: $IOS_DEVICE"
}

ios_reset() {
	[[ $DRY_RUN == "1" ]] || need_cmd xcrun
	ios_run clear
	[[ $DRY_RUN == "1" ]] || echo "Cleared iOS screenshot mode for simulator: $IOS_DEVICE"
}

android_run() {
	local -a cmd=(adb)
	[[ -n $ANDROID_SERIAL ]] && cmd+=(-s "$ANDROID_SERIAL")
	cmd+=("$@")

	if [[ $DRY_RUN == "1" ]]; then
		printf '%q ' "${cmd[@]}"
		printf '\n'
	else
		"${cmd[@]}"
	fi
}

android_try() {
	# Best-effort Android command; suppress errors/noise in non-dry-run mode.
	local -a cmd=(adb)
	[[ -n $ANDROID_SERIAL ]] && cmd+=(-s "$ANDROID_SERIAL")
	cmd+=("$@")

	if [[ $DRY_RUN == "1" ]]; then
		printf '%q ' "${cmd[@]}"
		printf '\n'
	else
		"${cmd[@]}" >/dev/null 2>&1
	fi
}

android_note_fail() {
	local label="$1"
	ANDROID_FAILS+=("$label")
}

android_apply() {
	[[ $DRY_RUN == "1" ]] || need_cmd adb
	ANDROID_FAILS=()

	# 1) Fixed time/date (emulator-friendly)
	if ! android_try shell su 0 date "$(android_adb_date "$ANDROID_DATE_YMD" "$ANDROID_TIME_HHMM")"; then
		if ! android_try shell su -c "date $(android_adb_date "$ANDROID_DATE_YMD" "$ANDROID_TIME_HHMM")"; then
			android_try shell date "$(android_adb_date "$ANDROID_DATE_YMD" "$ANDROID_TIME_HHMM")" ||
				android_note_fail "time (needs root?)"
		fi
	fi

	# 2) Battery: unplugged, 100%, discharging
	android_run shell dumpsys battery unplug || android_note_fail "battery unplug"
	android_run shell dumpsys battery set level "$ANDROID_BATTERY_LEVEL" || android_note_fail "battery level"
	android_run shell dumpsys battery set status "$ANDROID_BATTERY_STATUS" || android_note_fail "battery status"

	# 2b) Full cellular signal (emulator console)
	android_try emu gsm signal 31 || android_note_fail "gsm signal"
	android_try emu gsm voice home || android_note_fail "gsm voice"
	android_try emu gsm data home || android_note_fail "gsm data"

	# 3) Stable network icons: airplane OFF, Wi-Fi ON
	android_try shell cmd connectivity airplane-mode disable || android_note_fail "airplane mode (cmd)"
	android_run shell settings put global airplane_mode_on 0 || android_note_fail "airplane mode (settings)"
	android_run shell svc wifi enable || android_note_fail "wifi enable"

	# 4) Hide system chrome
	android_run shell settings put global policy_control immersive.full='*' ||
		android_note_fail "immersive mode"

	# 5) Disable animations
	android_run shell settings put global window_animation_scale 0 || android_note_fail "window animation"
	android_run shell settings put global transition_animation_scale 0 || android_note_fail "transition animation"
	android_run shell settings put global animator_duration_scale 0 || android_note_fail "animator duration"

	# 6) Disable heads-up notifications
	android_run shell settings put global heads_up_notifications_enabled 0 ||
		android_note_fail "heads-up notifications"

	if [[ $DRY_RUN == "1" ]]; then
		return
	fi

	if [[ ${#ANDROID_FAILS[@]} -gt 0 ]]; then
		echo "Applied Android screenshot mode (with failures):"
		printf '  - %s\n' "${ANDROID_FAILS[@]}"
		echo "Tip: time changes require a userdebug/eng emulator (adb root)."
	else
		echo "Applied Android screenshot mode."
	fi
}

android_reset() {
	[[ $DRY_RUN == "1" ]] || need_cmd adb
	ANDROID_FAILS=()

	android_run shell dumpsys battery reset || android_note_fail "battery reset"

	if android_try shell cmd connectivity airplane-mode disable; then
		android_run shell settings put global airplane_mode_on 0 || android_note_fail "airplane mode (settings)"
	else
		android_note_fail "airplane mode (cmd)"
		android_run shell settings put global airplane_mode_on 0 || android_note_fail "airplane mode (settings)"
		android_try shell am broadcast -a android.intent.action.AIRPLANE_MODE --ez state false ||
			android_note_fail "airplane mode (broadcast)"
	fi
	android_run shell svc wifi enable || android_note_fail "wifi enable"

	android_run shell settings put global policy_control null || android_note_fail "immersive mode reset"

	android_run shell settings put global window_animation_scale 1 || android_note_fail "window animation"
	android_run shell settings put global transition_animation_scale 1 || android_note_fail "transition animation"
	android_run shell settings put global animator_duration_scale 1 || android_note_fail "animator duration"

	android_run shell settings put global heads_up_notifications_enabled 1 ||
		android_note_fail "heads-up notifications"

	if [[ $DRY_RUN == "1" ]]; then
		return
	fi

	if [[ ${#ANDROID_FAILS[@]} -gt 0 ]]; then
		echo "Reset Android screenshot mode (with failures):"
		printf '  - %s\n' "${ANDROID_FAILS[@]}"
	else
		echo "Reset Android screenshot mode (best-effort)."
	fi
}

main() {
	parse_args "$@"
	validate_inputs

	case "$CMD" in
	apply)
		if [[ $PLATFORM == "ios" ]]; then
			ios_apply
		else
			android_apply
		fi
		;;
	reset | clear)
		if [[ $PLATFORM == "ios" ]]; then
			ios_reset
		else
			android_reset
		fi
		;;
	-h | --help)
		usage
		;;
	*)
		die "Unknown command: $CMD"
		;;
	esac
}

main "$@"
